/* hs_establish_intro.h -- generated by by Trunnel v1.4.5.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#ifndef TRUNNEL_HS_ESTABLISH_INTRO_H
#define TRUNNEL_HS_ESTABLISH_INTRO_H

#include <stdint.h>
#include "trunnel.h"

#define SHA3_256_MAC_LEN 32
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_EXTENSION)
struct extension_st {
  uint8_t field_type;
  uint8_t field_len;
  TRUNNEL_DYNARRAY_HEAD(, uint8_t) field;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct extension_st extension_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_HS_ESTABLISH_INTRO_CELL)
struct hs_establish_intro_cell_st {
  const uint8_t *start_cell;
  uint8_t auth_key_type;
  uint16_t auth_key_len;
  TRUNNEL_DYNARRAY_HEAD(, uint8_t) auth_key;
  uint8_t n_extensions;
  TRUNNEL_DYNARRAY_HEAD(, struct extension_st *) extensions;
  const uint8_t *end_mac_fields;
  uint8_t handshake_sha3_256[SHA3_256_MAC_LEN];
  uint16_t siglen;
  const uint8_t *end_sig_fields;
  TRUNNEL_DYNARRAY_HEAD(, uint8_t) sig;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct hs_establish_intro_cell_st hs_establish_intro_cell_t;
/** Return a newly allocated extension with all elements set to zero.
 */
extension_t *extension_new(void);
/** Release all storage held by the extension in 'victim'. (Do nothing
 * if 'victim' is NULL.)
 */
void extension_free(extension_t *victim);
/** Try to parse a extension from the buffer in 'input', using up to
 * 'len_in' bytes from the input buffer. On success, return the number
 * of bytes consumed and set *output to the newly allocated
 * extension_t. On failure, return -2 if the input appears truncated,
 * and -1 if the input is otherwise invalid.
 */
ssize_t extension_parse(extension_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * extension in 'obj'. On failure, return a negative value. Note that
 * this value may be an overestimate, and can even be an underestimate
 * for certain unencodeable objects.
 */
ssize_t extension_encoded_len(const extension_t *obj);
/** Try to encode the extension from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t extension_encode(uint8_t *output, size_t avail, const extension_t *input);
/** Check whether the internal state of the extension in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *extension_check(const extension_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int extension_clear_errors(extension_t *obj);
/** Return the value of the field_type field of the extension_t in
 * 'inp'
 */
uint8_t extension_get_field_type(extension_t *inp);
/** Set the value of the field_type field of the extension_t in 'inp'
 * to 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int extension_set_field_type(extension_t *inp, uint8_t val);
/** Return the value of the field_len field of the extension_t in
 * 'inp'
 */
uint8_t extension_get_field_len(extension_t *inp);
/** Set the value of the field_len field of the extension_t in 'inp'
 * to 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int extension_set_field_len(extension_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the field field of
 * the extension_t in 'inp'.
 */
size_t extension_getlen_field(const extension_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * field of the extension_t in 'inp'.
 */
uint8_t extension_get_field(extension_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * field of the extension_t in 'inp', so that it will hold the value
 * 'elt'.
 */
int extension_set_field(extension_t *inp, size_t idx, uint8_t elt);
/** Append a new element 'elt' to the dynamic array field field of the
 * extension_t in 'inp'.
 */
int extension_add_field(extension_t *inp, uint8_t elt);
/** Return a pointer to the variable-length array field field of
 * 'inp'.
 */
uint8_t * extension_getarray_field(extension_t *inp);
/** Change the length of the variable-length array field field of
 * 'inp' to 'newlen'.Fill extra elements with 0. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int extension_setlen_field(extension_t *inp, size_t newlen);
/** Return a newly allocated hs_establish_intro_cell with all elements
 * set to zero.
 */
hs_establish_intro_cell_t *hs_establish_intro_cell_new(void);
/** Release all storage held by the hs_establish_intro_cell in
 * 'victim'. (Do nothing if 'victim' is NULL.)
 */
void hs_establish_intro_cell_free(hs_establish_intro_cell_t *victim);
/** Try to parse a hs_establish_intro_cell from the buffer in 'input',
 * using up to 'len_in' bytes from the input buffer. On success,
 * return the number of bytes consumed and set *output to the newly
 * allocated hs_establish_intro_cell_t. On failure, return -2 if the
 * input appears truncated, and -1 if the input is otherwise invalid.
 */
ssize_t hs_establish_intro_cell_parse(hs_establish_intro_cell_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * hs_establish_intro_cell in 'obj'. On failure, return a negative
 * value. Note that this value may be an overestimate, and can even be
 * an underestimate for certain unencodeable objects.
 */
ssize_t hs_establish_intro_cell_encoded_len(const hs_establish_intro_cell_t *obj);
/** Try to encode the hs_establish_intro_cell from 'input' into the
 * buffer at 'output', using up to 'avail' bytes of the output buffer.
 * On success, return the number of bytes used. On failure, return -2
 * if the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t hs_establish_intro_cell_encode(uint8_t *output, size_t avail, const hs_establish_intro_cell_t *input);
/** Check whether the internal state of the hs_establish_intro_cell in
 * 'obj' is consistent. Return NULL if it is, and a short message if
 * it is not.
 */
const char *hs_establish_intro_cell_check(const hs_establish_intro_cell_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int hs_establish_intro_cell_clear_errors(hs_establish_intro_cell_t *obj);
/** Return the position for start_cell when we parsed this object
 */
const uint8_t * hs_establish_intro_cell_get_start_cell(const hs_establish_intro_cell_t *inp);
/** Return the value of the auth_key_type field of the
 * hs_establish_intro_cell_t in 'inp'
 */
uint8_t hs_establish_intro_cell_get_auth_key_type(hs_establish_intro_cell_t *inp);
/** Set the value of the auth_key_type field of the
 * hs_establish_intro_cell_t in 'inp' to 'val'. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int hs_establish_intro_cell_set_auth_key_type(hs_establish_intro_cell_t *inp, uint8_t val);
/** Return the value of the auth_key_len field of the
 * hs_establish_intro_cell_t in 'inp'
 */
uint16_t hs_establish_intro_cell_get_auth_key_len(hs_establish_intro_cell_t *inp);
/** Set the value of the auth_key_len field of the
 * hs_establish_intro_cell_t in 'inp' to 'val'. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int hs_establish_intro_cell_set_auth_key_len(hs_establish_intro_cell_t *inp, uint16_t val);
/** Return the length of the dynamic array holding the auth_key field
 * of the hs_establish_intro_cell_t in 'inp'.
 */
size_t hs_establish_intro_cell_getlen_auth_key(const hs_establish_intro_cell_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * auth_key of the hs_establish_intro_cell_t in 'inp'.
 */
uint8_t hs_establish_intro_cell_get_auth_key(hs_establish_intro_cell_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * auth_key of the hs_establish_intro_cell_t in 'inp', so that it will
 * hold the value 'elt'.
 */
int hs_establish_intro_cell_set_auth_key(hs_establish_intro_cell_t *inp, size_t idx, uint8_t elt);
/** Append a new element 'elt' to the dynamic array field auth_key of
 * the hs_establish_intro_cell_t in 'inp'.
 */
int hs_establish_intro_cell_add_auth_key(hs_establish_intro_cell_t *inp, uint8_t elt);
/** Return a pointer to the variable-length array field auth_key of
 * 'inp'.
 */
uint8_t * hs_establish_intro_cell_getarray_auth_key(hs_establish_intro_cell_t *inp);
/** Change the length of the variable-length array field auth_key of
 * 'inp' to 'newlen'.Fill extra elements with 0. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int hs_establish_intro_cell_setlen_auth_key(hs_establish_intro_cell_t *inp, size_t newlen);
/** Return the value of the n_extensions field of the
 * hs_establish_intro_cell_t in 'inp'
 */
uint8_t hs_establish_intro_cell_get_n_extensions(hs_establish_intro_cell_t *inp);
/** Set the value of the n_extensions field of the
 * hs_establish_intro_cell_t in 'inp' to 'val'. Return 0 on success;
 * return -1 and set the error code on 'inp' on failure.
 */
int hs_establish_intro_cell_set_n_extensions(hs_establish_intro_cell_t *inp, uint8_t val);
/** Return the length of the dynamic array holding the extensions
 * field of the hs_establish_intro_cell_t in 'inp'.
 */
size_t hs_establish_intro_cell_getlen_extensions(const hs_establish_intro_cell_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * extensions of the hs_establish_intro_cell_t in 'inp'.
 */
struct extension_st * hs_establish_intro_cell_get_extensions(hs_establish_intro_cell_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * extensions of the hs_establish_intro_cell_t in 'inp', so that it
 * will hold the value 'elt'. Free the previous value, if any.
 */
int hs_establish_intro_cell_set_extensions(hs_establish_intro_cell_t *inp, size_t idx, struct extension_st * elt);
/** As hs_establish_intro_cell_set_extensions, but does not free the
 * previous value.
 */
int hs_establish_intro_cell_set0_extensions(hs_establish_intro_cell_t *inp, size_t idx, struct extension_st * elt);
/** Append a new element 'elt' to the dynamic array field extensions
 * of the hs_establish_intro_cell_t in 'inp'.
 */
int hs_establish_intro_cell_add_extensions(hs_establish_intro_cell_t *inp, struct extension_st * elt);
/** Return a pointer to the variable-length array field extensions of
 * 'inp'.
 */
struct extension_st * * hs_establish_intro_cell_getarray_extensions(hs_establish_intro_cell_t *inp);
/** Change the length of the variable-length array field extensions of
 * 'inp' to 'newlen'.Fill extra elements with NULL; free removed
 * elements. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int hs_establish_intro_cell_setlen_extensions(hs_establish_intro_cell_t *inp, size_t newlen);
/** Return the position for end_mac_fields when we parsed this object
 */
const uint8_t * hs_establish_intro_cell_get_end_mac_fields(const hs_establish_intro_cell_t *inp);
/** Return the (constant) length of the array holding the
 * handshake_sha3_256 field of the hs_establish_intro_cell_t in 'inp'.
 */
size_t hs_establish_intro_cell_getlen_handshake_sha3_256(const hs_establish_intro_cell_t *inp);
/** Return the element at position 'idx' of the fixed array field
 * handshake_sha3_256 of the hs_establish_intro_cell_t in 'inp'.
 */
uint8_t hs_establish_intro_cell_get_handshake_sha3_256(const hs_establish_intro_cell_t *inp, size_t idx);
/** Change the element at position 'idx' of the fixed array field
 * handshake_sha3_256 of the hs_establish_intro_cell_t in 'inp', so
 * that it will hold the value 'elt'.
 */
int hs_establish_intro_cell_set_handshake_sha3_256(hs_establish_intro_cell_t *inp, size_t idx, uint8_t elt);
/** Return a pointer to the SHA3_256_MAC_LEN-element array field
 * handshake_sha3_256 of 'inp'.
 */
uint8_t * hs_establish_intro_cell_getarray_handshake_sha3_256(hs_establish_intro_cell_t *inp);
/** Return the value of the siglen field of the
 * hs_establish_intro_cell_t in 'inp'
 */
uint16_t hs_establish_intro_cell_get_siglen(hs_establish_intro_cell_t *inp);
/** Set the value of the siglen field of the hs_establish_intro_cell_t
 * in 'inp' to 'val'. Return 0 on success; return -1 and set the error
 * code on 'inp' on failure.
 */
int hs_establish_intro_cell_set_siglen(hs_establish_intro_cell_t *inp, uint16_t val);
/** Return the position for end_sig_fields when we parsed this object
 */
const uint8_t * hs_establish_intro_cell_get_end_sig_fields(const hs_establish_intro_cell_t *inp);
/** Return the length of the dynamic array holding the sig field of
 * the hs_establish_intro_cell_t in 'inp'.
 */
size_t hs_establish_intro_cell_getlen_sig(const hs_establish_intro_cell_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * sig of the hs_establish_intro_cell_t in 'inp'.
 */
uint8_t hs_establish_intro_cell_get_sig(hs_establish_intro_cell_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * sig of the hs_establish_intro_cell_t in 'inp', so that it will hold
 * the value 'elt'.
 */
int hs_establish_intro_cell_set_sig(hs_establish_intro_cell_t *inp, size_t idx, uint8_t elt);
/** Append a new element 'elt' to the dynamic array field sig of the
 * hs_establish_intro_cell_t in 'inp'.
 */
int hs_establish_intro_cell_add_sig(hs_establish_intro_cell_t *inp, uint8_t elt);
/** Return a pointer to the variable-length array field sig of 'inp'.
 */
uint8_t * hs_establish_intro_cell_getarray_sig(hs_establish_intro_cell_t *inp);
/** Change the length of the variable-length array field sig of 'inp'
 * to 'newlen'.Fill extra elements with 0. Return 0 on success; return
 * -1 and set the error code on 'inp' on failure.
 */
int hs_establish_intro_cell_setlen_sig(hs_establish_intro_cell_t *inp, size_t newlen);


#endif
