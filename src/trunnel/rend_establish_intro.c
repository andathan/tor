/* rend_establish_intro.c -- generated by Trunnel v1.4.4.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#include <stdlib.h>
#include "trunnel-impl.h"

#include "rend_establish_intro.h"

#define TRUNNEL_SET_ERROR_CODE(obj) \
  do {                              \
    (obj)->trunnel_error_code_ = 1; \
  } while (0)

#if defined(__COVERITY__) || defined(__clang_analyzer__)
/* If we're runnning a static analysis tool, we don't want it to complain
 * that some of our remaining-bytes checks are dead-code. */
int rendestablishintro_deadcode_dummy__ = 0;
#define OR_DEADCODE_DUMMY || rendestablishintro_deadcode_dummy__
#else
#define OR_DEADCODE_DUMMY
#endif

#define CHECK_REMAINING(nbytes, label)                           \
  do {                                                           \
    if (remaining < (nbytes) OR_DEADCODE_DUMMY) {                \
      goto label;                                                \
    }                                                            \
  } while (0)

extension_t *
extension_new(void)
{
  extension_t *val = trunnel_calloc(1, sizeof(extension_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
extension_clear(extension_t *obj)
{
  (void) obj;
  TRUNNEL_DYNARRAY_WIPE(&obj->field);
  TRUNNEL_DYNARRAY_CLEAR(&obj->field);
}

void
extension_free(extension_t *obj)
{
  if (obj == NULL)
    return;
  extension_clear(obj);
  trunnel_memwipe(obj, sizeof(extension_t));
  trunnel_free_(obj);
}

uint8_t
extension_get_field_type(extension_t *inp)
{
  return inp->field_type;
}
int
extension_set_field_type(extension_t *inp, uint8_t val)
{
  inp->field_type = val;
  return 0;
}
uint8_t
extension_get_field_len(extension_t *inp)
{
  return inp->field_len;
}
int
extension_set_field_len(extension_t *inp, uint8_t val)
{
  inp->field_len = val;
  return 0;
}
size_t
extension_getlen_field(const extension_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->field);
}

uint8_t
extension_get_field(extension_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->field, idx);
}

int
extension_set_field(extension_t *inp, size_t idx, uint8_t elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->field, idx, elt);
  return 0;
}
int
extension_add_field(extension_t *inp, uint8_t elt)
{
#if SIZE_MAX >= UINT8_MAX
  if (inp->field.n_ == UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(uint8_t, &inp->field, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

uint8_t *
extension_getarray_field(extension_t *inp)
{
  return inp->field.elts_;
}
int
extension_setlen_field(extension_t *inp, size_t newlen)
{
  uint8_t *newptr;
#if UINT8_MAX < SIZE_MAX
  if (newlen > UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->field.allocated_,
                 &inp->field.n_, inp->field.elts_, newlen,
                 sizeof(inp->field.elts_[0]), (trunnel_free_fn_t) NULL,
                 &inp->trunnel_error_code_);
  if (newptr == NULL)
    goto trunnel_alloc_failed;
  inp->field.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
const char *
extension_check(const extension_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  if (TRUNNEL_DYNARRAY_LEN(&obj->field) != obj->field_len)
    return "Length mismatch for field";
  return NULL;
}

ssize_t
extension_encoded_len(const extension_t *obj)
{
  ssize_t result = 0;

  if (NULL != extension_check(obj))
     return -1;


  /* Length of u8 field_type */
  result += 1;

  /* Length of u8 field_len */
  result += 1;

  /* Length of u8 field[field_len] */
  result += TRUNNEL_DYNARRAY_LEN(&obj->field);
  return result;
}
int
extension_clear_errors(extension_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
extension_encode(uint8_t *output, const size_t avail, const extension_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = extension_encoded_len(obj);
#endif

  if (NULL != (msg = extension_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 field_type */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->field_type));
  written += 1; ptr += 1;

  /* Encode u8 field_len */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->field_len));
  written += 1; ptr += 1;

  /* Encode u8 field[field_len] */
  {
    size_t elt_len = TRUNNEL_DYNARRAY_LEN(&obj->field);
    trunnel_assert(obj->field_len == elt_len);
    trunnel_assert(written <= avail);
    if (avail - written < elt_len)
      goto truncated;
    if (elt_len)
      memcpy(ptr, obj->field.elts_, elt_len);
    written += elt_len; ptr += elt_len;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As extension_parse(), but do not allocate the output object.
 */
static ssize_t
extension_parse_into(extension_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u8 field_type */
  CHECK_REMAINING(1, truncated);
  obj->field_type = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u8 field_len */
  CHECK_REMAINING(1, truncated);
  obj->field_len = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u8 field[field_len] */
  CHECK_REMAINING(obj->field_len, truncated);
  TRUNNEL_DYNARRAY_EXPAND(uint8_t, &obj->field, obj->field_len, {});
  obj->field.n_ = obj->field_len;
  if (obj->field_len)
    memcpy(obj->field.elts_, ptr, obj->field_len);
  ptr += obj->field_len; remaining -= obj->field_len;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 trunnel_alloc_failed:
  return -1;
}

ssize_t
extension_parse(extension_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = extension_new();
  if (NULL == *output)
    return -1;
  result = extension_parse_into(*output, input, len_in);
  if (result < 0) {
    extension_free(*output);
    *output = NULL;
  }
  return result;
}
rend_establish_intro_t *
rend_establish_intro_new(void)
{
  rend_establish_intro_t *val = trunnel_calloc(1, sizeof(rend_establish_intro_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
rend_establish_intro_clear(rend_establish_intro_t *obj)
{
  (void) obj;
  TRUNNEL_DYNARRAY_WIPE(&obj->auth_key);
  TRUNNEL_DYNARRAY_CLEAR(&obj->auth_key);
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->extensions); ++idx) {
      extension_free(TRUNNEL_DYNARRAY_GET(&obj->extensions, idx));
    }
  }
  TRUNNEL_DYNARRAY_WIPE(&obj->extensions);
  TRUNNEL_DYNARRAY_CLEAR(&obj->extensions);
  TRUNNEL_DYNARRAY_WIPE(&obj->sig);
  TRUNNEL_DYNARRAY_CLEAR(&obj->sig);
}

void
rend_establish_intro_free(rend_establish_intro_t *obj)
{
  if (obj == NULL)
    return;
  rend_establish_intro_clear(obj);
  trunnel_memwipe(obj, sizeof(rend_establish_intro_t));
  trunnel_free_(obj);
}

const uint8_t *
rend_establish_intro_get_start_cell(const rend_establish_intro_t *inp)
{
  return inp->start_cell;
}
uint8_t
rend_establish_intro_get_auth_key_type(rend_establish_intro_t *inp)
{
  return inp->auth_key_type;
}
int
rend_establish_intro_set_auth_key_type(rend_establish_intro_t *inp, uint8_t val)
{
  inp->auth_key_type = val;
  return 0;
}
uint16_t
rend_establish_intro_get_auth_key_len(rend_establish_intro_t *inp)
{
  return inp->auth_key_len;
}
int
rend_establish_intro_set_auth_key_len(rend_establish_intro_t *inp, uint16_t val)
{
  inp->auth_key_len = val;
  return 0;
}
size_t
rend_establish_intro_getlen_auth_key(const rend_establish_intro_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->auth_key);
}

uint8_t
rend_establish_intro_get_auth_key(rend_establish_intro_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->auth_key, idx);
}

int
rend_establish_intro_set_auth_key(rend_establish_intro_t *inp, size_t idx, uint8_t elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->auth_key, idx, elt);
  return 0;
}
int
rend_establish_intro_add_auth_key(rend_establish_intro_t *inp, uint8_t elt)
{
#if SIZE_MAX >= UINT16_MAX
  if (inp->auth_key.n_ == UINT16_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(uint8_t, &inp->auth_key, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

uint8_t *
rend_establish_intro_getarray_auth_key(rend_establish_intro_t *inp)
{
  return inp->auth_key.elts_;
}
int
rend_establish_intro_setlen_auth_key(rend_establish_intro_t *inp, size_t newlen)
{
  uint8_t *newptr;
#if UINT16_MAX < SIZE_MAX
  if (newlen > UINT16_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->auth_key.allocated_,
                 &inp->auth_key.n_, inp->auth_key.elts_, newlen,
                 sizeof(inp->auth_key.elts_[0]), (trunnel_free_fn_t) NULL,
                 &inp->trunnel_error_code_);
  if (newptr == NULL)
    goto trunnel_alloc_failed;
  inp->auth_key.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
uint8_t
rend_establish_intro_get_n_extensions(rend_establish_intro_t *inp)
{
  return inp->n_extensions;
}
int
rend_establish_intro_set_n_extensions(rend_establish_intro_t *inp, uint8_t val)
{
  inp->n_extensions = val;
  return 0;
}
size_t
rend_establish_intro_getlen_extensions(const rend_establish_intro_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->extensions);
}

struct extension_st *
rend_establish_intro_get_extensions(rend_establish_intro_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->extensions, idx);
}

int
rend_establish_intro_set_extensions(rend_establish_intro_t *inp, size_t idx, struct extension_st * elt)
{
  extension_t *oldval = TRUNNEL_DYNARRAY_GET(&inp->extensions, idx);
  if (oldval && oldval != elt)
    extension_free(oldval);
  return rend_establish_intro_set0_extensions(inp, idx, elt);
}
int
rend_establish_intro_set0_extensions(rend_establish_intro_t *inp, size_t idx, struct extension_st * elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->extensions, idx, elt);
  return 0;
}
int
rend_establish_intro_add_extensions(rend_establish_intro_t *inp, struct extension_st * elt)
{
#if SIZE_MAX >= UINT8_MAX
  if (inp->extensions.n_ == UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(struct extension_st *, &inp->extensions, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

struct extension_st * *
rend_establish_intro_getarray_extensions(rend_establish_intro_t *inp)
{
  return inp->extensions.elts_;
}
int
rend_establish_intro_setlen_extensions(rend_establish_intro_t *inp, size_t newlen)
{
  struct extension_st * *newptr;
#if UINT8_MAX < SIZE_MAX
  if (newlen > UINT8_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->extensions.allocated_,
                 &inp->extensions.n_, inp->extensions.elts_, newlen,
                 sizeof(inp->extensions.elts_[0]), (trunnel_free_fn_t) extension_free,
                 &inp->trunnel_error_code_);
  if (newptr == NULL)
    goto trunnel_alloc_failed;
  inp->extensions.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
const uint8_t *
rend_establish_intro_get_end_mac_fields(const rend_establish_intro_t *inp)
{
  return inp->end_mac_fields;
}
size_t
rend_establish_intro_getlen_handshake_sha3_256(const rend_establish_intro_t *inp)
{
  (void)inp;  return SHA3_256_MAC_LEN;
}

uint8_t
rend_establish_intro_get_handshake_sha3_256(const rend_establish_intro_t *inp, size_t idx)
{
  trunnel_assert(idx < SHA3_256_MAC_LEN);
  return inp->handshake_sha3_256[idx];
}

int
rend_establish_intro_set_handshake_sha3_256(rend_establish_intro_t *inp, size_t idx, uint8_t elt)
{
  trunnel_assert(idx < SHA3_256_MAC_LEN);
  inp->handshake_sha3_256[idx] = elt;
  return 0;
}

uint8_t *
rend_establish_intro_getarray_handshake_sha3_256(rend_establish_intro_t *inp)
{
  return inp->handshake_sha3_256;
}
uint16_t
rend_establish_intro_get_siglen(rend_establish_intro_t *inp)
{
  return inp->siglen;
}
int
rend_establish_intro_set_siglen(rend_establish_intro_t *inp, uint16_t val)
{
  inp->siglen = val;
  return 0;
}
const uint8_t *
rend_establish_intro_get_end_sig_fields(const rend_establish_intro_t *inp)
{
  return inp->end_sig_fields;
}
size_t
rend_establish_intro_getlen_sig(const rend_establish_intro_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->sig);
}

uint8_t
rend_establish_intro_get_sig(rend_establish_intro_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->sig, idx);
}

int
rend_establish_intro_set_sig(rend_establish_intro_t *inp, size_t idx, uint8_t elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->sig, idx, elt);
  return 0;
}
int
rend_establish_intro_add_sig(rend_establish_intro_t *inp, uint8_t elt)
{
#if SIZE_MAX >= UINT16_MAX
  if (inp->sig.n_ == UINT16_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(uint8_t, &inp->sig, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

uint8_t *
rend_establish_intro_getarray_sig(rend_establish_intro_t *inp)
{
  return inp->sig.elts_;
}
int
rend_establish_intro_setlen_sig(rend_establish_intro_t *inp, size_t newlen)
{
  uint8_t *newptr;
#if UINT16_MAX < SIZE_MAX
  if (newlen > UINT16_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->sig.allocated_,
                 &inp->sig.n_, inp->sig.elts_, newlen,
                 sizeof(inp->sig.elts_[0]), (trunnel_free_fn_t) NULL,
                 &inp->trunnel_error_code_);
  if (newptr == NULL)
    goto trunnel_alloc_failed;
  inp->sig.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
const char *
rend_establish_intro_check(const rend_establish_intro_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  if (TRUNNEL_DYNARRAY_LEN(&obj->auth_key) != obj->auth_key_len)
    return "Length mismatch for auth_key";
  {
    const char *msg;

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->extensions); ++idx) {
      if (NULL != (msg = extension_check(TRUNNEL_DYNARRAY_GET(&obj->extensions, idx))))
        return msg;
    }
  }
  if (TRUNNEL_DYNARRAY_LEN(&obj->extensions) != obj->n_extensions)
    return "Length mismatch for extensions";
  switch (obj->auth_key_type) {

    case 2:
      break;

    default:
        return "Bad tag for union";
      break;
  }
  if (TRUNNEL_DYNARRAY_LEN(&obj->sig) != obj->siglen)
    return "Length mismatch for sig";
  return NULL;
}

ssize_t
rend_establish_intro_encoded_len(const rend_establish_intro_t *obj)
{
  ssize_t result = 0;

  if (NULL != rend_establish_intro_check(obj))
     return -1;


  /* Length of u8 auth_key_type */
  result += 1;

  /* Length of u16 auth_key_len */
  result += 2;

  /* Length of u8 auth_key[auth_key_len] */
  result += TRUNNEL_DYNARRAY_LEN(&obj->auth_key);

  /* Length of u8 n_extensions */
  result += 1;

  /* Length of struct extension extensions[n_extensions] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->extensions); ++idx) {
      result += extension_encoded_len(TRUNNEL_DYNARRAY_GET(&obj->extensions, idx));
    }
  }
  switch (obj->auth_key_type) {

    case 2:

      /* Length of u8 handshake_sha3_256[SHA3_256_MAC_LEN] */
      result += SHA3_256_MAC_LEN;
      break;

    default:
      trunnel_assert(0);
      break;
  }

  /* Length of u16 siglen */
  result += 2;

  /* Length of u8 sig[siglen] */
  result += TRUNNEL_DYNARRAY_LEN(&obj->sig);
  return result;
}
int
rend_establish_intro_clear_errors(rend_establish_intro_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
rend_establish_intro_encode(uint8_t *output, const size_t avail, const rend_establish_intro_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = rend_establish_intro_encoded_len(obj);
#endif

  if (NULL != (msg = rend_establish_intro_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u8 auth_key_type */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->auth_key_type));
  written += 1; ptr += 1;

  /* Encode u16 auth_key_len */
  trunnel_assert(written <= avail);
  if (avail - written < 2)
    goto truncated;
  trunnel_set_uint16(ptr, trunnel_htons(obj->auth_key_len));
  written += 2; ptr += 2;

  /* Encode u8 auth_key[auth_key_len] */
  {
    size_t elt_len = TRUNNEL_DYNARRAY_LEN(&obj->auth_key);
    trunnel_assert(obj->auth_key_len == elt_len);
    trunnel_assert(written <= avail);
    if (avail - written < elt_len)
      goto truncated;
    if (elt_len)
      memcpy(ptr, obj->auth_key.elts_, elt_len);
    written += elt_len; ptr += elt_len;
  }

  /* Encode u8 n_extensions */
  trunnel_assert(written <= avail);
  if (avail - written < 1)
    goto truncated;
  trunnel_set_uint8(ptr, (obj->n_extensions));
  written += 1; ptr += 1;

  /* Encode struct extension extensions[n_extensions] */
  {

    unsigned idx;
    for (idx = 0; idx < TRUNNEL_DYNARRAY_LEN(&obj->extensions); ++idx) {
      trunnel_assert(written <= avail);
      result = extension_encode(ptr, avail - written, TRUNNEL_DYNARRAY_GET(&obj->extensions, idx));
      if (result < 0)
        goto fail; /* XXXXXXX !*/
      written += result; ptr += result;
    }
  }

  /* Encode union handshake[auth_key_type] */
  trunnel_assert(written <= avail);
  switch (obj->auth_key_type) {

    case 2:

      /* Encode u8 handshake_sha3_256[SHA3_256_MAC_LEN] */
      trunnel_assert(written <= avail);
      if (avail - written < SHA3_256_MAC_LEN)
        goto truncated;
      memcpy(ptr, obj->handshake_sha3_256, SHA3_256_MAC_LEN);
      written += SHA3_256_MAC_LEN; ptr += SHA3_256_MAC_LEN;
      break;

    default:
      trunnel_assert(0);
      break;
  }

  /* Encode u16 siglen */
  trunnel_assert(written <= avail);
  if (avail - written < 2)
    goto truncated;
  trunnel_set_uint16(ptr, trunnel_htons(obj->siglen));
  written += 2; ptr += 2;

  /* Encode u8 sig[siglen] */
  {
    size_t elt_len = TRUNNEL_DYNARRAY_LEN(&obj->sig);
    trunnel_assert(obj->siglen == elt_len);
    trunnel_assert(written <= avail);
    if (avail - written < elt_len)
      goto truncated;
    if (elt_len)
      memcpy(ptr, obj->sig.elts_, elt_len);
    written += elt_len; ptr += elt_len;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As rend_establish_intro_parse(), but do not allocate the output
 * object.
 */
static ssize_t
rend_establish_intro_parse_into(rend_establish_intro_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;
  obj->start_cell = ptr;

  /* Parse u8 auth_key_type */
  CHECK_REMAINING(1, truncated);
  obj->auth_key_type = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse u16 auth_key_len */
  CHECK_REMAINING(2, truncated);
  obj->auth_key_len = trunnel_ntohs(trunnel_get_uint16(ptr));
  remaining -= 2; ptr += 2;

  /* Parse u8 auth_key[auth_key_len] */
  CHECK_REMAINING(obj->auth_key_len, truncated);
  TRUNNEL_DYNARRAY_EXPAND(uint8_t, &obj->auth_key, obj->auth_key_len, {});
  obj->auth_key.n_ = obj->auth_key_len;
  if (obj->auth_key_len)
    memcpy(obj->auth_key.elts_, ptr, obj->auth_key_len);
  ptr += obj->auth_key_len; remaining -= obj->auth_key_len;

  /* Parse u8 n_extensions */
  CHECK_REMAINING(1, truncated);
  obj->n_extensions = (trunnel_get_uint8(ptr));
  remaining -= 1; ptr += 1;

  /* Parse struct extension extensions[n_extensions] */
  TRUNNEL_DYNARRAY_EXPAND(extension_t *, &obj->extensions, obj->n_extensions, {});
  {
    extension_t * elt;
    unsigned idx;
    for (idx = 0; idx < obj->n_extensions; ++idx) {
      result = extension_parse(&elt, ptr, remaining);
      if (result < 0)
        goto relay_fail;
      trunnel_assert((size_t)result <= remaining);
      remaining -= result; ptr += result;
      TRUNNEL_DYNARRAY_ADD(extension_t *, &obj->extensions, elt, {extension_free(elt);});
    }
  }
  obj->end_mac_fields = ptr;

  /* Parse union handshake[auth_key_type] */
  switch (obj->auth_key_type) {

    case 2:

      /* Parse u8 handshake_sha3_256[SHA3_256_MAC_LEN] */
      CHECK_REMAINING(SHA3_256_MAC_LEN, truncated);
      memcpy(obj->handshake_sha3_256, ptr, SHA3_256_MAC_LEN);
      remaining -= SHA3_256_MAC_LEN; ptr += SHA3_256_MAC_LEN;
      break;

    default:
      goto fail;
      break;
  }

  /* Parse u16 siglen */
  CHECK_REMAINING(2, truncated);
  obj->siglen = trunnel_ntohs(trunnel_get_uint16(ptr));
  remaining -= 2; ptr += 2;
  obj->end_sig_fields = ptr;

  /* Parse u8 sig[siglen] */
  CHECK_REMAINING(obj->siglen, truncated);
  TRUNNEL_DYNARRAY_EXPAND(uint8_t, &obj->sig, obj->siglen, {});
  obj->sig.n_ = obj->siglen;
  if (obj->siglen)
    memcpy(obj->sig.elts_, ptr, obj->siglen);
  ptr += obj->siglen; remaining -= obj->siglen;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 relay_fail:
  trunnel_assert(result < 0);
  return result;
 trunnel_alloc_failed:
  return -1;
 fail:
  result = -1;
  return result;
}

ssize_t
rend_establish_intro_parse(rend_establish_intro_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = rend_establish_intro_new();
  if (NULL == *output)
    return -1;
  result = rend_establish_intro_parse_into(*output, input, len_in);
  if (result < 0) {
    rend_establish_intro_free(*output);
    *output = NULL;
  }
  return result;
}
